{
    "actions": [
    ],
    "checksum": "",
    "dashboardLayout": {
        "autoLayout": true,
        "windowOrder": [
        ]
    },
    "decoder": 3,
    "frameDetection": 2,
    "frameEnd": "\\n",
    "frameParser": "/**\n * Modbus Frame Parser for Serial Studio\n * Hydraulic Test Stand Simulator\n *\n * Parses Modbus protocol frames into an array of values.\n * Works with both Modbus TCP and RTU (without CRC, as Serial Studio handles it).\n *\n * INPUT FORMAT: Binary Modbus ADU without CRC\n *   [Slave Address][Function Code][Data...]\n *\n * OUTPUT ARRAY: Extracted register values from the Modbus response\n *\n * Register Map:\n *   HR[0]: Emergency Stop    (0=OK, 1=Triggered)\n *   HR[1]: Start LED         (0=Off, 1=Running)\n *   HR[2]: Temperature       (°F, 72-180)\n *   HR[3]: Pressure          (PSI, 0-3000)\n *   HR[4]: Motor RPM         (0-3600)\n *   HR[5]: Valve Position    (%, 0-100)\n *   HR[6]: Flow Rate         (GPM × 10, divide by 10 for actual)\n *   HR[7]: Motor Load        (%, 0-100)\n *   HR[8]: Vibration         (mm/s × 10, divide by 10 for actual)\n *\n * Note: This parser requires Binary (Direct) decoder mode in the Project Editor.\n */\n\n//------------------------------------------------------------------------------\n// Configuration\n//------------------------------------------------------------------------------\n\n/**\n * Total number of values in the output array.\n * Matches the hydraulic test stand register count.\n */\nconst numItems = 9;\n\n/**\n * Starting register address offset.\n * Set to 0 for 0-based addressing (most common).\n */\nconst registerOffset = 0;\n\n/**\n * Scaling factors for registers that need division.\n * Index -> divisor (1 = no scaling)\n */\nconst scalingFactors = {\n  0: 1,     // E-Stop: no scaling\n  1: 1,     // Start LED: no scaling\n  2: 1,     // Temperature: no scaling (°F)\n  3: 1,     // Pressure: no scaling (PSI)\n  4: 1,     // Motor RPM: no scaling\n  5: 1,     // Valve Position: no scaling (%)\n  6: 10,    // Flow Rate: divide by 10 (GPM)\n  7: 1,     // Motor Load: no scaling (%)\n  8: 10     // Vibration: divide by 10 (mm/s)\n};\n\n/**\n * Array to hold all parsed register values.\n * Initialized to 0, updated as frames are received.\n */\nconst parsedValues = new Array(numItems).fill(0);\n\n//------------------------------------------------------------------------------\n// Frame Parser Function\n//------------------------------------------------------------------------------\n\n/**\n * Parses a Modbus response frame into an array of register values.\n *\n * Frame structure (as received from Serial Studio Modbus driver):\n *   Byte 0:     Slave/Unit address\n *   Byte 1:     Function code\n *   Byte 2+:    Data (varies by function code)\n *\n * Supported function codes:\n *   0x01: Read Coils - Response contains bit-packed coil values\n *   0x02: Read Discrete Inputs - Response contains bit-packed input values\n *   0x03: Read Holding Registers - Response contains 16-bit register values\n *   0x04: Read Input Registers - Response contains 16-bit register values\n *   0x06: Write Single Register - Echo response with address and value\n *   0x10: Write Multiple Registers - Response with start address and quantity\n *   0x8X: Exception response - Error code in data byte\n *\n * Example frame for FC03 (Read Holding Registers) - 9 registers:\n *   [01 03 12 00 00 00 01 00 48 05 DC 07 08 00 32 00 C8 00 32 00 19]\n *    │  │  │  └─────────────────────────────────────────────────────┴── Register values\n *    │  │  └── Byte count (18 = 9 registers × 2 bytes)\n *    │  └── Function code (0x03)\n *    └── Slave address (1)\n *\n * @param {array} frame - Binary Modbus frame (byte array) from Serial Studio\n * @returns {array} Array of parsed values for Serial Studio datasets\n */\nfunction parse(frame) {\n  // Validate minimum frame length: address + function code + at least 1 data byte\n  if (frame.length < 3) {\n    return parsedValues;\n  }\n\n  // Extract header fields\n  var slaveAddress = frame[0];\n  var functionCode = frame[1];\n\n  //----------------------------------------------------------------------------\n  // Handle Read Holding Registers (0x03) and Read Input Registers (0x04)\n  //----------------------------------------------------------------------------\n  if (functionCode === 0x03 || functionCode === 0x04) {\n    // Response format: [Slave][FC][ByteCount][Data...]\n    var byteCount = frame[2];\n    var registerCount = byteCount / 2;\n\n    // Extract 16-bit register values (big-endian) and apply scaling\n    for (var i = 0; i < registerCount && i < numItems; i++) {\n      var offset = 3 + (i * 2);\n      if (offset + 1 < frame.length) {\n        // Big-endian: high byte first, then low byte\n        var highByte = frame[offset];\n        var lowByte = frame[offset + 1];\n        var rawValue = (highByte << 8) | lowByte;\n        \n        // Apply scaling factor if defined\n        var scale = scalingFactors[i] || 1;\n        parsedValues[i] = rawValue / scale;\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Handle Read Coils (0x01) and Read Discrete Inputs (0x02)\n  //----------------------------------------------------------------------------\n  else if (functionCode === 0x01 || functionCode === 0x02) {\n    // Response format: [Slave][FC][ByteCount][CoilData...]\n    var byteCount = frame[2];\n\n    // Extract bit values from packed bytes\n    var bitIndex = 0;\n    for (var byteIdx = 0; byteIdx < byteCount && bitIndex < numItems; byteIdx++) {\n      var dataByte = frame[3 + byteIdx];\n      for (var bit = 0; bit < 8 && bitIndex < numItems; bit++) {\n        parsedValues[bitIndex] = (dataByte >> bit) & 0x01;\n        bitIndex++;\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Handle Write Single Register (0x06) - Echo response\n  //----------------------------------------------------------------------------\n  else if (functionCode === 0x06) {\n    // Response format: [Slave][FC][AddrHi][AddrLo][ValueHi][ValueLo]\n    if (frame.length >= 6) {\n      var registerAddress = (frame[2] << 8) | frame[3];\n      var registerValue = (frame[4] << 8) | frame[5];\n      var index = registerAddress - registerOffset;\n\n      if (index >= 0 && index < numItems) {\n        var scale = scalingFactors[index] || 1;\n        parsedValues[index] = registerValue / scale;\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Handle Write Multiple Registers (0x10) - Confirmation response\n  //----------------------------------------------------------------------------\n  else if (functionCode === 0x10) {\n    // Response format: [Slave][FC][AddrHi][AddrLo][QuantityHi][QuantityLo]\n    if (frame.length >= 6) {\n      var startAddress = (frame[2] << 8) | frame[3];\n      var quantity = (frame[4] << 8) | frame[5];\n      // Note: The response only confirms the write, no data values returned\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Handle Write Single Coil (0x05) - Echo response\n  //----------------------------------------------------------------------------\n  else if (functionCode === 0x05) {\n    // Response format: [Slave][FC][AddrHi][AddrLo][ValueHi][ValueLo]\n    // Value is 0xFF00 for ON, 0x0000 for OFF\n    if (frame.length >= 6) {\n      var coilAddress = (frame[2] << 8) | frame[3];\n      var coilValue = (frame[4] << 8) | frame[5];\n      var index = coilAddress - registerOffset;\n\n      if (index >= 0 && index < numItems) {\n        parsedValues[index] = (coilValue === 0xFF00) ? 1 : 0;\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n  // Handle Exception Response (0x80 + original function code)\n  //----------------------------------------------------------------------------\n  else if (functionCode >= 0x80) {\n    var originalFunction = functionCode & 0x7F;\n    var exceptionCode = frame[2];\n\n    // Log exception for debugging\n    var exceptionMessages = {\n      0x01: \"Illegal Function\",\n      0x02: \"Illegal Data Address\",\n      0x03: \"Illegal Data Value\",\n      0x04: \"Server Device Failure\",\n      0x05: \"Acknowledge\",\n      0x06: \"Server Device Busy\",\n      0x08: \"Memory Parity Error\",\n      0x0A: \"Gateway Path Unavailable\",\n      0x0B: \"Gateway Target Device Failed to Respond\"\n    };\n\n    var message = exceptionMessages[exceptionCode] || \"Unknown Exception\";\n    console.log(\"Modbus Exception - FC:\" + originalFunction.toString(16) +\n                \" Code:\" + exceptionCode.toString(16) + \" (\" + message + \")\");\n\n    // Don't modify parsedValues on exception - keep last known good values\n  }\n\n  return parsedValues;\n}\n",
    "frameStart": "$",
    "groups": [
        {
            "datasets": [
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 1,
                    "led": true,
                    "ledHigh": 1,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 0,
                    "plotMin": 0,
                    "title": "Emergency Stop",
                    "units": "",
                    "value": "--.--",
                    "widget": "",
                    "widgetMax": 100,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 2,
                    "led": true,
                    "ledHigh": 1,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 0,
                    "plotMin": 0,
                    "title": "Running",
                    "units": "",
                    "value": "--.--",
                    "widget": "",
                    "widgetMax": 100,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 3,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 0,
                    "plotMin": 0,
                    "title": "Temperature",
                    "units": "°F",
                    "value": "--.--",
                    "widget": "bar",
                    "widgetMax": 200,
                    "widgetMin": 50,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": true,
                    "alarmHigh": 2800,
                    "alarmLow": 0,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 4,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 0,
                    "plotMin": 0,
                    "title": "Pressure",
                    "units": "PSI",
                    "value": "--.--",
                    "widget": "gauge",
                    "widgetMax": 3000,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": true,
                    "alarmHigh": 3200,
                    "alarmLow": 0,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 5,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 3600,
                    "plotMin": 0,
                    "title": "Pump Motor",
                    "units": "RPM",
                    "value": "--.--",
                    "widget": "gauge",
                    "widgetMax": 3600,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 6,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 100,
                    "plotMin": 0,
                    "title": "Valve Position",
                    "units": "%",
                    "value": "--.--",
                    "widget": "bar",
                    "widgetMax": 100,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 7,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 100,
                    "plotMin": 0,
                    "title": "Flow Rate",
                    "units": "GPM",
                    "value": "--.--",
                    "widget": "",
                    "widgetMax": 50,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 8,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 100,
                    "plotMin": 0,
                    "title": "Motor Load",
                    "units": "%",
                    "value": "--.--",
                    "widget": "",
                    "widgetMax": 50,
                    "widgetMin": 0,
                    "xAxis": -1
                },
                {
                    "alarmEnabled": false,
                    "alarmHigh": 80,
                    "alarmLow": 20,
                    "fft": false,
                    "fftMax": 0,
                    "fftMin": 0,
                    "fftSamples": 256,
                    "fftSamplingRate": 100,
                    "graph": false,
                    "index": 9,
                    "led": false,
                    "ledHigh": 80,
                    "log": false,
                    "overviewDisplay": false,
                    "plotMax": 15,
                    "plotMin": 0,
                    "title": "Vibration",
                    "units": "mm/s",
                    "value": "--.--",
                    "widget": "",
                    "widgetMax": 50,
                    "widgetMin": 0,
                    "xAxis": -1
                }
            ],
            "title": "Holding Registers",
            "widget": "datagrid"
        }
    ],
    "hexadecimalDelimiters": false,
    "title": "Modbus PLC Simulator"
}
