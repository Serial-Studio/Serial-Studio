#!/usr/bin/env python3
"""
Advanced Exploitation Suite for Serial Studio

This module contains sophisticated attack techniques designed to bypass
security controls and exploit subtle vulnerabilities.

Attack categories:
- Race conditions and TOCTOU attacks
- Integer overflows and underflows
- Memory corruption attempts
- Parser state confusion
- Side-channel timing attacks
- Thread exhaustion
- File descriptor exhaustion
- Logic bugs in state machines

Copyright (C) 2020-2025 Alex Spataru
SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-SerialStudio-Commercial
"""

import json
import socket
import threading
import time
import uuid
import sys
import struct
from pathlib import Path
from typing import List
import base64
import pytest

sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.api_client import SerialStudioClient, APIError


class AdvancedExploiter:
    """Advanced exploitation techniques"""

    def __init__(self, host="127.0.0.1", port=7777):
        self.host = host
        self.port = port
        self.exploits = []
        self.crashes = []

    def log_exploit(self, name, success, details):
        """Log exploitation attempt"""
        result = {"name": name, "success": success, "details": details}
        self.exploits.append(result)
        if success:
            print(f"[PWNED] {name}: {details}")
        else:
            print(f"[BLOCKED] {name}: {details}")


@pytest.mark.timeout(60)
def test_race_conditions(exploiter):
    """Exploit race conditions in connection/disconnection"""
    print("\n[*] Testing race condition exploits...")

    # Attack 1: TOCTOU - Connect/Disconnect race
    print("  - TOCTOU attack on connect/disconnect state...")

    def rapid_toggle():
        try:
            with SerialStudioClient() as client:
                for _ in range(500):
                    try:
                        client.command("io.manager.connect")
                        client.command("io.manager.disconnect")
                    except:
                        pass
        except:
            pass

    # Launch 20 threads to create race condition
    threads = [threading.Thread(target=rapid_toggle) for _ in range(20)]
    start = time.time()

    for t in threads:
        t.start()

    time.sleep(3)

    # Check if server crashed
    try:
        with SerialStudioClient() as client:
            client.command("api.getCommands")
            exploiter.log_exploit(
                "TOCTOU Connect/Disconnect",
                False,
                "Server survived race condition",
            )
    except:
        exploiter.log_exploit(
            "TOCTOU Connect/Disconnect", True, "Server crashed or unresponsive!"
        )

    for t in threads:
        t.join(timeout=5)

    # Attack 2: Race on configuration changes
    print("  - Racing configuration changes...")

    def race_config():
        try:
            with SerialStudioClient() as client:
                for i in range(100):
                    client.command("dashboard.setFPS", {"fps": i % 60 + 1})
                    client.command("dashboard.setPoints", {"points": i % 1000})
        except:
            pass

    threads = [threading.Thread(target=race_config) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join(timeout=5)

    # Attack 3: Race on frame parser reset
    print("  - Racing frame parser resets...")

    def race_parser():
        try:
            with SerialStudioClient() as client:
                sequences = [b"/*", b"*/", b"@@", b"##", b"{{", b"}}"]
                for i in range(50):
                    start = sequences[i % len(sequences)]
                    end = sequences[(i + 1) % len(sequences)]
                    client.configure_frame_parser(
                        start_sequence=start.decode(),
                        end_sequence=end.decode(),
                        operation_mode=i % 3,
                    )
        except:
            pass

    threads = [threading.Thread(target=race_parser) for _ in range(5)]
    for t in threads:
        t.start()
    for t in threads:
        t.join(timeout=10)


@pytest.mark.timeout(90)
def test_integer_overflow(exploiter):
    """Test integer overflow vulnerabilities"""
    print("\n[*] Testing integer overflow exploits...")

    # Attack 1: Overflow FPS value
    print("  - Testing FPS integer overflow...")
    overflow_values = [
        2147483647,  # Max int32
        2147483648,  # Max int32 + 1
        4294967295,  # Max uint32
        4294967296,  # Max uint32 + 1
        9223372036854775807,  # Max int64
        -2147483648,  # Min int32
        -9223372036854775808,  # Min int64
    ]

    for val in overflow_values:
        try:
            with SerialStudioClient(timeout=3.0) as client:
                result = client.command("dashboard.setFPS", {"fps": val})
                exploiter.log_exploit(
                    "Integer Overflow FPS", True, f"Accepted value: {val}"
                )
        except (APIError, TimeoutError, ConnectionError):
            # Server rejected or timed out - expected for invalid values
            pass

    # Attack 2: Overflow points value
    print("  - Testing points integer overflow...")
    for val in overflow_values:
        try:
            with SerialStudioClient(timeout=3.0) as client:
                result = client.command("dashboard.setPoints", {"points": val})
                exploiter.log_exploit(
                    "Integer Overflow Points", True, f"Accepted value: {val}"
                )
        except (APIError, TimeoutError, ConnectionError):
            # Server rejected or timed out - expected for invalid values
            pass

    # Attack 3: Negative array indices
    print("  - Testing negative array access...")
    try:
        with SerialStudioClient() as client:
            # Try to access negative indices through batch
            batch = [{"command": "api.getCommands"} for _ in range(-1, 10)]
            client.batch(batch)
    except:
        pass


def test_memory_corruption(exploiter):
    """Attempt memory corruption through buffer overflows"""
    print("\n[*] Testing memory corruption attacks...")

    # Attack 1: Overflow frame delimiters
    print("  - Overflowing frame delimiter buffers...")
    huge_delimiter = "A" * (1024 * 1024 * 10)  # 10MB delimiter

    try:
        with SerialStudioClient() as client:
            client.configure_frame_parser(
                start_sequence=huge_delimiter,
                end_sequence=huge_delimiter,
                operation_mode=0,
            )
            exploiter.log_exploit(
                "Delimiter Buffer Overflow", True, "10MB delimiter accepted"
            )
    except:
        exploiter.log_exploit(
            "Delimiter Buffer Overflow", False, "Huge delimiter rejected"
        )

    # Attack 2: Corrupt JSON with extreme nesting
    print("  - Deep JSON nesting to overflow stack...")
    depth = 100000
    nested = '{"a":' * depth + "1" + "}" * depth

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((exploiter.host, exploiter.port))
        sock.sendall(nested.encode() + b"\n")
        sock.settimeout(2.0)
        response = sock.recv(4096)
        sock.close()

        if not response or b"error" not in response.lower():
            exploiter.log_exploit(
                "JSON Stack Overflow", True, f"{depth} level nesting accepted"
            )
    except:
        pass

    # Attack 3: Unicode buffer overflow
    print("  - Unicode normalization bomb...")
    # Characters that expand significantly during normalization
    unicode_bomb = "\u0061\u0301" * 100000  # √° repeated

    try:
        with SerialStudioClient() as client:
            result = client.command("project.setTitle", {"title": unicode_bomb})
            exploiter.log_exploit(
                "Unicode Normalization Bomb", True, "Unicode bomb accepted"
            )
    except:
        pass


def test_parser_confusion(exploiter):
    """Exploit parser state machine bugs"""
    print("\n[*] Testing parser confusion attacks...")

    # Attack 1: Delimiter injection
    print("  - Injecting delimiters in data stream...")

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((exploiter.host, exploiter.port))

        # Configure parser with /* */ delimiters
        with SerialStudioClient() as client:
            client.configure_frame_parser(
                start_sequence="/*", end_sequence="*/", operation_mode=0
            )

        # Send data with embedded delimiters to confuse parser
        confused = b"/*FRAME1*//*FRAME2*//*INCOMPLETE"
        confused += b"/**//**/"  # Empty frames
        confused += b"/*" * 1000 + b"*/"  # Many opens, one close

        sock.sendall(confused)
        time.sleep(1)

        # Check if server is confused
        msg = '{"type":"command","id":"test","command":"api.getCommands"}\n'
        sock.sendall(msg.encode())
        sock.settimeout(2.0)
        response = sock.recv(4096)
        sock.close()

        if response:
            exploiter.log_exploit(
                "Parser Delimiter Confusion", False, "Parser handled confusion"
            )
    except:
        exploiter.log_exploit(
            "Parser Delimiter Confusion", True, "Parser crashed or hung!"
        )

    # Attack 2: Newline injection
    print("  - Newline injection in JSON strings...")
    payloads = [
        '{"type":"command","id":"test\nINJECTED","command":"api.getCommands"}\n',
        '{"type":"command","id":"test\r\nINJECTED","command":"api.getCommands"}\n',
        '{"type":"command","id":"test\x00NULL","command":"api.getCommands"}\n',
    ]

    for payload in payloads:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            sock.sendall(payload.encode())
            sock.settimeout(1.0)
            response = sock.recv(4096)
            sock.close()
        except:
            pass


def test_timing_attacks(exploiter):
    """Side-channel timing attacks"""
    print("\n[*] Testing timing side-channel attacks...")

    # Attack 1: Command enumeration via timing
    print("  - Command enumeration via timing analysis...")

    def measure_timing(command):
        times = []
        for _ in range(50):
            start = time.perf_counter()
            try:
                with SerialStudioClient() as client:
                    client.command(command)
            except:
                pass
            elapsed = time.perf_counter() - start
            times.append(elapsed)
        return sum(times) / len(times)

    # Valid vs invalid commands should have different timing
    valid_time = measure_timing("api.getCommands")
    invalid_time = measure_timing("nonexistent.command.12345")

    timing_diff = abs(valid_time - invalid_time)
    if timing_diff > 0.001:  # 1ms difference
        exploiter.log_exploit(
            "Timing Side Channel",
            True,
            f"Command existence leaked via timing: {timing_diff*1000:.2f}ms diff",
        )


@pytest.mark.timeout(60)
def test_resource_exhaustion(exploiter):
    """Advanced resource exhaustion"""
    print("\n[*] Testing advanced resource exhaustion...")

    # Attack 1: File descriptor exhaustion
    print("  - Exhausting file descriptors...")
    sockets = []
    try:
        for i in range(1000):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            sockets.append(sock)
            # Don't send data, just hold connections open
    except Exception as e:
        print(f"    Opened {len(sockets)} sockets before: {e}")

    # Check if server still accepts new connections
    try:
        test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        test_sock.connect((exploiter.host, exploiter.port))
        test_sock.close()
        exploiter.log_exploit(
            "FD Exhaustion", False, f"Server survived {len(sockets)} connections"
        )
    except:
        exploiter.log_exploit(
            "FD Exhaustion", True, "Server refusing connections!"
        )

    # Cleanup
    for sock in sockets:
        try:
            sock.close()
        except:
            pass

    # Attack 2: Thread exhaustion via concurrent requests
    print("  - Thread pool exhaustion...")

    def blocking_request():
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            # Send partial message to tie up a thread
            sock.sendall(b'{"type":"command","id":"block",')
            time.sleep(30)  # Hold for 30 seconds
            sock.close()
        except:
            pass

    threads = [threading.Thread(target=blocking_request) for _ in range(100)]
    for t in threads:
        t.start()

    time.sleep(2)

    # Check if server is still responsive
    try:
        with SerialStudioClient() as client:
            client.command("api.getCommands")
        exploiter.log_exploit("Thread Exhaustion", False, "Server still responsive")
    except:
        exploiter.log_exploit("Thread Exhaustion", True, "Server starved of threads!")

    # Attack 3: Queue overflow with message flooding
    print("  - Queue overflow attack...")

    def flood_queue():
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            for i in range(10000):
                msg = {
                    "type": "command",
                    "id": f"flood-{i}",
                    "command": "api.getCommands",
                }
                sock.sendall(json.dumps(msg).encode() + b"\n")
            sock.close()
        except:
            pass

    # Multiple threads flooding simultaneously
    threads = [threading.Thread(target=flood_queue) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join(timeout=10)


def test_deserialization_attacks(exploiter):
    """JSON deserialization exploitation"""
    print("\n[*] Testing deserialization attacks...")

    # Attack 1: Circular references
    print("  - Testing circular reference handling...")
    try:
        # Can't create true circular ref in JSON, but can create self-similar structures
        circular = {"type": "command", "id": "test", "command": "api.getCommands"}
        circular["params"] = {"self": circular}

        # Will fail to serialize, but try anyway
        with SerialStudioClient() as client:
            # Create deeply recursive structure
            recursive = {"a": {}}
            current = recursive["a"]
            for i in range(1000):
                current["b"] = {}
                current = current["b"]

            msg = {
                "type": "command",
                "id": "recursive",
                "command": "project.loadFromJSON",
                "params": {"config": recursive},
            }

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            sock.sendall(json.dumps(msg).encode() + b"\n")
            sock.settimeout(5.0)
            response = sock.recv(4096)
            sock.close()

    except Exception as e:
        print(f"    Recursive structure: {e}")

    # Attack 2: Type confusion
    print("  - Testing type confusion...")
    type_confusion_payloads = [
        {"type": ["array", "instead", "of", "string"]},
        {"type": {"nested": "object"}},
        {"type": 12345},
        {"type": True},
        {"type": None},
        {"id": ["array", "id"]},
        {"command": {"nested": "command"}},
    ]

    for payload in type_confusion_payloads:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            sock.sendall(json.dumps(payload).encode() + b"\n")
            sock.settimeout(1.0)
            response = sock.recv(4096)
            sock.close()
        except:
            pass


def test_logic_bombs(exploiter):
    """Exploit state machine logic errors"""
    print("\n[*] Testing logic bomb exploits...")

    # Attack 1: Invalid state transitions
    print("  - Forcing invalid state transitions...")

    try:
        with SerialStudioClient() as client:
            # Try to export before connecting
            client.command("csv.export.setEnabled", {"enabled": True})

            # Try to disconnect before connecting
            client.command("io.manager.disconnect")

            # Try to write data without device
            import base64

            data = base64.b64encode(b"INJECT").decode()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            msg = {"type": "raw", "id": str(uuid.uuid4()), "data": data}
            sock.sendall(json.dumps(msg).encode() + b"\n")
            sock.settimeout(2.0)
            response = sock.recv(4096)
            sock.close()

    except Exception as e:
        print(f"    State validation: {e}")

    # Attack 2: Rapid mode switching
    print("  - Rapid operation mode switching...")

    try:
        with SerialStudioClient() as client:
            for i in range(500):
                mode = i % 3
                client.configure_frame_parser(
                    start_sequence="/*",
                    end_sequence="*/",
                    operation_mode=mode,
                )
    except Exception as e:
        print(f"    Mode switching: {e}")


def test_compression_bomb(exploiter):
    """Test compression bomb / zip bomb equivalent"""
    print("\n[*] Testing compression-like attacks...")

    # Attack: Send highly repetitive data that might trigger compression
    print("  - Sending highly repetitive payload...")

    try:
        # Create a message with extreme redundancy
        redundant = {"type": "command", "id": "A" * 1000000, "command": "api.getCommands"}

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((exploiter.host, exploiter.port))
        payload = json.dumps(redundant).encode() + b"\n"
        print(f"    Payload size: {len(payload) / 1024 / 1024:.2f} MB")
        sock.sendall(payload)
        sock.settimeout(5.0)
        response = sock.recv(4096)
        sock.close()

        if response:
            exploiter.log_exploit("Compression Bomb", False, "Redundant data handled")
    except Exception as e:
        print(f"    Exception: {e}")


@pytest.mark.timeout(90)
def test_batch_exploits(exploiter):
    """Advanced batch command exploitation"""
    print("\n[*] Testing advanced batch exploits...")

    # Attack 1: Exactly at batch limit (256)
    print("  - Testing batch size limit bypass...")
    try:
        with SerialStudioClient(timeout=10.0) as client:
            # Try exactly 256 (at limit)
            batch = [{"command": "api.getCommands"} for _ in range(256)]
            result = client.batch(batch, timeout=30.0)
            print("    256 commands: ACCEPTED")

    except (APIError, TimeoutError, ConnectionError) as e:
        print(f"    256 commands: REJECTED ({e})")

    # Try 257 in a new connection (over limit)
    try:
        with SerialStudioClient(timeout=10.0) as client:
            batch = [{"command": "api.getCommands"} for _ in range(257)]
            result = client.batch(batch, timeout=30.0)

            # Check if server returned error response
            if isinstance(result, dict) and result.get("error"):
                exploiter.log_exploit("Batch Limit Bypass", False, "Limit enforced via error response")
            else:
                exploiter.log_exploit("Batch Limit Bypass", True, "257 commands accepted!")

    except (APIError, ConnectionError) as e:
        # Server rejected and closed connection - CORRECT behavior
        exploiter.log_exploit("Batch Limit Bypass", False, f"Limit enforced: {e}")
    except TimeoutError:
        exploiter.log_exploit("Batch Limit", True, "Server hung on batch processing!")

    # Attack 2: Batch within batch (if possible)
    print("  - Testing nested batch commands...")
    try:
        # This might not work, but worth trying
        nested_batch = {
            "type": "batch",
            "id": str(uuid.uuid4()),
            "commands": [
                {
                    "type": "batch",
                    "id": str(uuid.uuid4()),
                    "commands": [{"command": "api.getCommands"} for _ in range(100)],
                }
                for _ in range(10)
            ],
        }

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((exploiter.host, exploiter.port))
        sock.sendall(json.dumps(nested_batch).encode() + b"\n")
        sock.settimeout(10.0)
        response = sock.recv(65536)
        sock.close()

    except Exception as e:
        print(f"    Nested batch: {e}")


def test_binary_injection(exploiter):
    """Inject binary data through various channels"""
    print("\n[*] Testing binary data injection...")

    # Attack 1: Binary in JSON strings
    print("  - Injecting binary in JSON strings...")
    binary_payloads = [
        b"\x00\x01\x02\x03\x04\x05",  # NULLs and control chars
        b"\xff\xfe\xfd\xfc",  # High bytes
        b"\x1b[31mRED\x1b[0m",  # ANSI escape codes
        b"\x7f" * 100,  # DEL characters
    ]

    for binary in binary_payloads:
        try:
            # Encode as base64 for raw message
            encoded = base64.b64encode(binary).decode()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((exploiter.host, exploiter.port))
            msg = {"type": "raw", "id": str(uuid.uuid4()), "data": encoded}
            sock.sendall(json.dumps(msg).encode() + b"\n")
            sock.settimeout(1.0)
            response = sock.recv(4096)
            sock.close()
        except:
            pass


def main():
    """Run advanced exploitation suite"""
    print("=" * 80)
    print("Serial Studio Advanced Exploitation Suite")
    print("=" * 80)
    print("\nRED TEAM MODE: Attempting sophisticated exploitation techniques")
    print("This will try to bypass security controls and crash the server.\n")

    exploiter = AdvancedExploiter()

    try:
        # Check connectivity
        with SerialStudioClient() as client:
            print("[+] Target acquired: Serial Studio API\n")

        # Run advanced attacks
        test_race_conditions(exploiter)
        test_integer_overflow(exploiter)
        test_memory_corruption(exploiter)
        test_parser_confusion(exploiter)
        test_timing_attacks(exploiter)
        test_resource_exhaustion(exploiter)
        test_deserialization_attacks(exploiter)
        test_logic_bombs(exploiter)
        test_compression_bomb(exploiter)
        test_batch_exploits(exploiter)
        test_binary_injection(exploiter)

    except KeyboardInterrupt:
        print("\n\n[!] Exploitation interrupted")

    finally:
        # Report
        print("\n" + "=" * 80)
        print("EXPLOITATION REPORT")
        print("=" * 80)

        successful = [e for e in exploiter.exploits if e["success"]]
        blocked = [e for e in exploiter.exploits if not e["success"]]

        print(f"\nüéØ Successful exploits: {len(successful)}")
        for exploit in successful:
            print(f"  [PWNED] {exploit['name']}: {exploit['details']}")

        print(f"\nüõ°Ô∏è  Blocked attacks: {len(blocked)}")
        for exploit in blocked[:10]:  # Show first 10
            print(f"  [DEFENDED] {exploit['name']}: {exploit['details']}")

        # Final check
        print("\n[*] Final server health check...")
        try:
            with SerialStudioClient() as client:
                client.command("api.getCommands")
                print("  ‚úÖ Server still alive and responsive")
        except:
            print("  ‚ùå SERVER DOWN - EXPLOITATION SUCCESSFUL!")

        print("\n" + "=" * 80)

    return 0


if __name__ == "__main__":
    exit(main())
